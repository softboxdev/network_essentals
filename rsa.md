
### Краткое описание для нетерпеливых

SHA-256 — это криптографический алгоритм, который принимает на вход сообщение (любого размера) и выдает на выходе уникальный "отпечаток" (хеш) длиной ровно 256 бит (32 байта). Если изменить хотя бы один бит во входном сообщении, его хеш изменится до неузнаваемости. Предсказать, как изменится хеш, или найти два сообщения с одинаковым хешем, практически невозможно.

---

### Подробное пошаговое объяснение

Работу SHA-256 можно разбить на несколько ключевых этапов.

#### Шаг 1: Предварительная обработка (Выравнивание и добавление длины)

Цель этого шага — преобразовать входное сообщение в такой вид, чтобы его длина была кратна 512 битам. Это необходимо для последующей обработки блоками.

1.  **Добавление бита `1`:** К концу исходного сообщения добавляется один бит `1`.
2.  **Добавление битов `0`:** Добавляется столько битов `0`, чтобы длина сообщения стала равной `448 по модулю 512` (то есть `длина % 512 = 448`). Минимальное количество нулей — 0, максимальное — 511.
3.  **Добавление длины сообщения:** В оставшиеся 64 бита (в конец выровненного блока) записывается длина исходного сообщения *в битах* представленная как 64-битное число с порядком байтов *big-endian*.

**Пример:** Если сообщение "abc", его предварительная обработка будет выглядеть так:
*   Исходное сообщение: `01100001 01100010 01100011` (это "a", "b", "c" в ASCII)
*   Добавляем `1`: `01100001 01100010 01100011 1`
*   Добавляем нули, пока длина не станет 448 mod 512. Для "abc" нужно добавить 423 нуля.
*   Добавляем длину: `... [64 бита, указывающие, что исходное сообщение было длиной 24 бита]`

В результате мы получаем сообщение, длина которого кратна 512 битам.

#### Шаг 2: Инициализация хеш-значения (H)

SHA-256 использует восемь 32-битных переменных, называемых **хеш-значением**. В начале работы они инициализируются определенными константами, которые являются дробными частями квадратных корней первых восьми простых чисел (2, 3, 5, 7, 11, 13, 17, 19).

```
h0 = 0x6a09e667
h1 = 0xbb67ae85
h2 = 0x3c6ef372
h3 = 0xa54ff53a
h4 = 0x510e527f
h5 = 0x9b05688c
h6 = 0x1f83d9ab
h7 = 0x5be0cd19
```

Эти значения являются "магическими" константами, которые обеспечивают отсутствие скрытых уязвимостей в алгоритме.

#### Шаг 3: Обработка сообщения блоками по 512 бит

Теперь выровненное сообщение разбивается на блоки по 512 бит каждый. Каждый блок обрабатывается в цикле, и результат обработки одного блока передается на вход при обработке следующего.

#### Шаг 4: Обработка одного блока (самая сложная часть)

Для каждого 512-битного блока выполняются следующие операции:

1.  **Подготовка расписания сообщений (Message Schedule, W[0..63]):**
    *   Первые 16 слов (по 32 бита каждое, всего 16*32=512 бит) копируются прямо из текущего обрабатываемого блока.
    *   Остальные 48 слов (с W[16] до W[63]) вычисляются по специальным формулам, которые включают **сдвиги (rotate), циклические сдвиги (shift) и XOR**. Это позволяет "распространить" влияние каждого бита исходного блока на все последующие вычисления.
    ```
    W[t] = σ1(W[t-2]) + W[t-7] + σ0(W[t-15]) + W[t-16]
    ```
    (где `σ0` и `σ1` — это функции, производящие сдвиги и вращения)
2.  **Инициализация рабочих переменных:**
    *   Текущие значения хеша (h0-h7) копируются в восемь временных рабочих переменных: a, b, c, d, e, f, g, h.

3.  **Основной цикл сжатия (64 раунда):**
    *   Это "сердце" SHA-256. Алгоритм выполняет 64 раунда, по одному для каждого слова из расписания сообщений `W[t]`.
    *   В каждом раунде вычисляются две временные переменные, `T1` и `T2`.
    *   Формулы для каждого раунда используют **битовые операции** (И, ИЛИ, XOR, НЕ) и **сдвиги**, что делает алгоритм очень эффективным для вычисления на процессорах.

        ```
        T1 = h + Σ1(e) + Ch(e, f, g) + K[t] + W[t]
        T2 = Σ0(a) + Maj(a, b, c)
        h = g
        g = f
        f = e
        e = d + T1
        d = c
        c = b
        b = a
        a = T1 + T2
        ```

    *   **`Ch` (Choice):** `Ch(e, f, g) = (e AND f) XOR ((NOT e) AND g)`
    *   **`Maj` (Majority):** `Maj(a, b, c) = (a AND b) XOR (a AND c) XOR (b AND c)`
    *   **`Σ0` и `Σ1`:** Функции, производящие сдвиги и вращения над своими аргументами.
    *   **`K[t]`:** Это 64 константы, которые представляют собой дробные части кубических корней первых 64 простых чисел. Как и начальные значения хеша, они являются "магическими" числами для обеспечения безопасности.

4.  **Получение нового промежуточного хеша:**
    *   После 64 раундов временные переменные a-h прибавляются к исходным значениям хеша h0-h7.
    ```
    h0 = h0 + a
    h1 = h1 + b
    ...
    h7 = h7 + h
    ```
    *   Результат становится новым хеш-значением для этого блока.

#### Шаг 5: Формирование окончательного хеша

После обработки всех блоков сообщения, восемь 32-битных переменных h0-h7 просто объединяются вместе (конкатенируются). В результате получается одна строка длиной 256 бит (32 байта). Это и есть окончательный хеш SHA-256.

Обычно его представляют в виде шестнадцатеричной строки из 64 символов (так как 256 бит / 4 бита на символ = 64 символа).

**Пример:**
`SHA-256("abc") = ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad`

---

### Ключевые свойства SHA-256

1.  **Детерминированность:** Один и тот же вход всегда дает один и тот же хеш.
2.  **Быстрота:** Вычисление хеша для любого сообщения происходит очень быстро.
3.  **Эффект лавины:** Малейшее изменение входа (даже один бит) полностью меняет хеш.
4.  **Необратимость (Свойство прообраза):** По имеющемуся хешу практически невозможно восстановить исходное сообщение.
5.  **Устойчивость к коллизиям:** Практически невозможно найти два разных сообщения с одинаковым хешем SHA-256.

### Где применяется?

*   **Криптовалюты (Bitcoin):** Для майнинга и построения хеш-деревьев Меркла.
*   **Цифровые подписи:** Подпись создается для хеша сообщения, а не для самого сообщения.
*   **Хранение паролей:** Сервера хранят только хеши паролей.
*   **Контроль целостности данных:** Проверка, что файл не был изменен при передаче.

Надеюсь, это объяснение помогло вам понять основы работы этого элегантного и мощного алгоритма!